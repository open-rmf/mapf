/*
 * Copyright (C) 2022 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

use std::sync::Arc;
use crate::{
    node,
    error::Error,
};

pub trait Goal<N> {
    fn is_satisfied(&self, node: &N) -> bool;
}

pub trait Expander {
    type Node;
}

pub trait InitAimless<Start>: Expander {
    type InitAimlessError: Error;

    type InitialAimlessNodes<'a>: IntoIterator<Item=Result<Arc<Self::Node>, Self::InitAimlessError>, IntoIter: 'a>
    where Self: 'a, Start: 'a;

    fn aimless_start<'a>(
        &'a self,
        start: &'a Start,
    ) -> Self::InitialAimlessNodes<'a>;
}

pub trait Aimless: Expander {
    type AimlessError: Error;

    type AimlessExpansion<'a>: IntoIterator<Item=Result<Arc<Self::Node>, Self::AimlessError>>
    where Self: 'a, Self::Node: 'a;

    fn aimless_expand<'a>(
        &'a self,
        parent: &'a Arc<Self::Node>,
    ) -> Self::AimlessExpansion<'a>;
}

pub trait InitTargeted<Start, G: Goal<Self::Node>>: Expander {
    /// The type of error that can occur during node initialization.
    type InitTargetedError: Error;

    /// An initial set of nodes, produced from a Start object
    type InitialTargetedNodes<'a>: IntoIterator<Item=Result<Arc<Self::Node>, Self::InitTargetedError>, IntoIter: 'a>
    where Self: 'a, Start: 'a, G: 'a;

    /// Generate an initial set of nodes based on the given start conditions
    fn start<'a>(
        &'a self,
        start: &'a Start,
        goal: &'a G,
    ) -> Self::InitialTargetedNodes<'a>;
}

pub trait Targeted<G: Goal<Self::Node>>: Expander {
    /// The type of error that can occur during expansion.
    type TargetedError: Error;

    /// An expansion that can be generated by this Expander
    type TargetedExpansion<'a>: IntoIterator<Item=Result<Arc<Self::Node>, Self::TargetedError>>
    where Self: 'a, Self::Node: 'a, G: 'a;

    /// Expand the given node
    fn expand<'a>(
        &'a self,
        parent: &'a Arc<Self::Node>,
        goal: &'a G,
    ) -> Self::TargetedExpansion<'a>;
}

pub trait Solvable: Expander {
    /// The representation of solutions that can be produced by this Expander
    type Solution;

    /// The type of error that can occur while constructing a solution
    type SolveError: Error;

    /// Make a Solution for the given solution node
    fn make_solution(&self, solution_node: &Arc<Self::Node>) -> Result<Self::Solution, Self::SolveError>;
}

/// A trait for nodes which can be inserted into a closed set. This trait is
/// used to inform planners what concrete type should be used as the closed set
/// for this node.
pub trait Closable: Expander {
    type ClosedSet: node::ClosedSet<Self::Node>;
}

/// The Reversible trait can be implemented by Expanders that support expanding
/// in reverse from a goal. Bidirectional algorithms can take advantage of this
/// trait.
pub trait Reversible: Expander<Node: node::Reversible> {
    type Reverse: Expander<Node=node::ReverseOf<Self::Node>>;
    type ReversalError: Error;

    /// Create a reverse expander for the algorithm to use.
    fn reverse(&self) -> Result<Self::Reverse, Self::ReversalError>;
}

/// A trait for reversible expanders that can find solutions where forward
/// nodes intersect with reverse nodes.
pub trait BidirSolvable: Reversible  + Solvable {
    type BidirSolveError: Error;

    /// Make a solution from a (Forward, Reverse) expansion node pair.
    fn make_bidirectional_solution(
        &self,
        forward_solution_node: &Arc<Self::Node>,
        reverse_solution_node: &Arc<<Self::Reverse as Expander>::Node>
    ) -> Result<Self::Solution, Self::BidirSolveError>;
}

pub type NodeOf<E> = <E as Expander>::Node;
pub type CostOf<E> = <NodeOf<E> as node::Weighted>::Cost;
pub type InitAimlessErrorOf<E, S> = <E as InitAimless<S>>::InitAimlessError;
pub type InitTargetedErrorOf<E, S, G> = <E as InitTargeted<S, G>>::InitTargetedError;
pub type ExpansionErrorOf<E, G> = <E as Targeted<G>>::TargetedError;
pub type AimlessErrorOf<E> = <E as Aimless>::AimlessError;
pub type SolveErrorOf<E> = <E as Solvable>::SolveError;
pub type SolutionOf<E> = <E as Solvable>::Solution;
pub type ReverseOf<E> = <E as Reversible>::Reverse;
pub type ReverseNodeOf<E> = <ReverseOf<E> as Expander>::Node;
pub type ReversalErrorOf<E> = <E as Reversible>::ReversalError;
pub type BidirSolveErrorOf<E> = <E as BidirSolvable>::BidirSolveError;
